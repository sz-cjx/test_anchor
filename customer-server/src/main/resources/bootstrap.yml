#自定义配置
arb:
  service:
    #  微服务名 需要自行修改
    name: customer
    #  端口号 需要申请,确保不重复
    port: 9509
server:
  port: ${arb.service.port}
  servlet:
    #  统一访问前缀
    context-path: /v3
spring:
  application:
    name: ${arb.service.name}
  cloud:
    config:
      label: master
      discovery:
        enabled: true
        service-id: config-server
      fail-fast: true
      retry:
        initial-interval: 1000
        multiplier: 1.1
        max-interval: 2000
        max-attempts: 6
  servlet:
    multipart:
      enabled: true
      file-size-threshold: 0
      max-file-size: 256Mb
      max-request-size: 256Mb
  # 数据库组件
  datasource:
    master:
      writer:
        type: com.alibaba.druid.pool.DruidDataSource # Druid数据库连接池
        driver-class-name: com.mysql.jdbc.Driver
        url: jdbc:mysql://${arb.database.writer.url}/${arb.database.schema}?charset=utf8mb4&useSSL=false&rewriteBatchedStatements=true&autoReconnect=true
        username: ${arb.database.username}
        password: ${arb.database.password}
        testOnBorrow: true                          # 指明是否从池中取出连接前进行检验，如果检验失败，则从池中取出连接并尝试取出另一个
        testOnReturn: true                          # 指明连接是否被空闲连接回收器（如果有）进行检验，如果检测失败，则连接将被从池中去除
        testWhileIdle: true
        timeBetweenEvictionRunsMillis: 60000        # 在空闲连接回收器线程运行期间休眠的时间值，姨毫秒为单位。如果设置为非整数，则不运行空闲连接回收器线程
        initialSize: 20
        minIdle: 20
        maxActive: 256
        maxWait: 60000                              # 配置获取连接等待超时的时间
        minEvictableIdleTimeMillis: 300000          # 配置一个连接在池中最小生存的时间，单位是毫秒
        validationQuery: SELECT'x'
        poolPreparedStatements: true                # 打开PSCache，并且指定每个连接上PSCache的大小
        maxPoolPreparedStatementPerConnectionSize: 20
        filters: stat,wall,slf4j                    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙，此处是filter修改的地方
      reader:
        type: com.alibaba.druid.pool.DruidDataSource # Druid数据库连接池
        driver-class-name: com.mysql.jdbc.Driver
        url: jdbc:mysql://${arb.database.reader.url}/${arb.database.schema}?charset=utf8mb4&useSSL=false&rewriteBatchedStatements=true&autoReconnect=true
        username: ${arb.database.username}
        password: ${arb.database.password}
        testOnBorrow: true                          # 指明是否从池中取出连接前进行检验，如果检验失败，则从池中取出连接并尝试取出另一个
        testOnReturn: true                          # 指明连接是否被空闲连接回收器（如果有）进行检验，如果检测失败，则连接将被从池中去除
        testWhileIdle: true
        timeBetweenEvictionRunsMillis: 60000        # 在空闲连接回收器线程运行期间休眠的时间值，姨毫秒为单位。如果设置为非整数，则不运行空闲连接回收器线程
        initialSize: 20
        minIdle: 20
        maxActive: 256
        maxWait: 60000                              # 配置获取连接等待超时的时间
        minEvictableIdleTimeMillis: 300000          # 配置一个连接在池中最小生存的时间，单位是毫秒
        validationQuery: SELECT'x'
        poolPreparedStatements: true                # 打开PSCache，并且指定每个连接上PSCache的大小
        maxPoolPreparedStatementPerConnectionSize: 20
        filters: stat,wall,slf4j                    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙，此处是filter修改的地方

  #  redis 组件, 选配 看自己的服务是否需要他
  redis:
    jedis:
      pool:
        maxTotal: 200
        minIdle: 1
        maxWaitMillis: 5000
        maxIdle: 5
        testOnBorrow: true
        testOnReturn: true
        testWhileIdle: true
    primary:
      writer:
        database: ${arb.redis.primary.writer.database}
        hostName: ${arb.redis.primary.writer.url}
        port: ${arb.redis.primary.writer.port}
      reader:
        database: ${arb.redis.primary.reader.database}
        hostName: ${arb.redis.primary.reader.url}
        port: ${arb.redis.primary.reader.port}

  #  消息队列组件, 选配 看自己的服务是否需要他
  rabbitmq:
    host: ${arb.rabbitmq.url}
    username: ${arb.rabbitmq.username}
    password: ${arb.rabbitmq.password}
    port: ${arb.rabbitmq.port}
    ssl:
      enabled: ${arb.rabbitmq.ssl.enabled}
      algorithm: ${arb.rabbitmq.ssl.algorithm}
    publisher-confirms: true
    publisher-returns: true
    listener:
      simple:
        acknowledge-mode: manual

eureka:
  instance:
    instance-id: ${arb.service.url}:${spring.application.name}:${arb.service.port}
    hostname: ${arb.service.url}
    ip-address: ${arb.service.url}
    lease-renewal-interval-in-seconds: 5
    lease-expiration-duration-in-seconds: 10
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://${arb.eureka.url}/eureka/
    healthcheck: enabled
---
spring:
  profiles: local-v3.2
arb:
  database:
    writer:
      url: 172.18.1.251:3308
    reader:
      url: 172.18.1.251:3308
    schema: employee
    username: root
    password: Arb@8888
  eureka:
    url: localhost:7901
  service:
    url: localhost
  redis:
    primary:
      writer:
        database: 2
        url: 172.18.1.251
        port: 6379
      reader:
        database: 2
        url: 172.18.1.251
        port: 6379
  rabbitmq:
    url: 172.18.1.251
    username: arbfintech
    password: Arb@8888
    port: 5672
    ssl:
      enabled: false
      algorithm: TLSv1.2
---
spring:
  profiles: develop-v3.2
arb:
  eureka:
    url: FRAMEWORK-EUREKA-SERVER-DEV-V3-2.us-west-1.elasticbeanstalk.com:7901
  service:
    url: MICROSERVICE-EMPLOYEE-DEV-V3-2.us-west-1.elasticbeanstalk.com
